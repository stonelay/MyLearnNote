## 链接

链接分为静态链接和动态链接，他们的机制和发生时机是不一样的。//TODO


编译通常是逐个文件进行的，每个源文件的编译都是独立的。所以编译过程中，对编译器来说只有当前的编译单元是可见的，至于定义在其他源文件或者库中定义的函数、方法和全局变量，则是未知的。如果被编译的文件里面需要引用到其他文件中的符号（函数、方法和全局变量），编译阶段该符号的引用地址是无法确定的，只有等连接器把所有文件链接到一起的时候才能确定最终地址。
此时生成的目标文件中的段(Segment)中的节(Section)中的外部函数调用指令的操作数部分以及外部全局变量符号的地址的值都将是0。在后续的链接过程中需要调整这些指令的操作数的值来进行重定位(Relocation)，为此系统在编译的目标文件中的对那些有外部符号引用的节(Section)中都会建立一个重定位表(Relocation table)。这个重定位表中的每个条目会将所有需要进行重定位的指令或者数据访问的位置信息以及引用的外部符号的信息记录起来，以便在链接时进行更新处理。下面的图表展示了这个结构：




链接符号的类型

符号定义的本质
符号定义的本质是：指被分配了存储空间。如果是函数名则指代码所在区；如果是变量名则指其所在的静态数据区。
所有定义的符号的值就是其目标所在的首地址。

因此，符号的解析就是将符号引用和符号定义建立关联后，将引用符号的地址重定位为相关联的符号定义的地址。
静态库中的符号表中保存的是所有目标文件中的符号表信息的集合。我们知道在程序链接时需要读取目标文件中的符号表信息才能决定其他目标文件中引用的符号信息是否真实存在，当其他目标文件引用的符号信息不存在或者找不到时就会报经典的符号信息不存在的错误。

而链接则将所有的源文件聚集在一起最后生成一个目标文件，其可见范围包含所有的源文件(也包括库)。因此，编译器通常不会也无法产生整个工程的全局符号表，其可见范围仅为单个被编译文件。而链接器读取所有输入文件，并按照一定的规则寻找每一个符号的定义并计算其地址(或者留下可重定位符号交由加载器在运行时计算)


仅由模块m定义和引用的本地符号。例如，在模块m中定义的带static的C函数和全局变量
如，swap.c中的static变量名bufp1.
注意：链接器的局部符号不是指程序中的局部变量（分配在栈中的临时性变量），链接器不关心这种局部变量



所以，在编译阶段

### 静态链接
// 空间与地址分配
1. 目标文件在被链接成可执行文件时，目标文件中的各个段，是怎么被合并的？
2. 在最终输出的可执行文件中，链接器如何为它们分配地址和空间的（为什么这么分配）。
// 符号解析与重定位
3. 输入段的最终地址被确认下来后，接下来就可以 符号解析和重定位。
4. 链接器的有部分工作 是对目标文件中对外部符号的引用（内部符号表）进行解析，这是对每段中需要重定位的指令进行修正。

//经过编译后，得到多个后缀为o的目标文件，链接的过程就是将这些目标文件合并的过程。

第一步，扫描所有需要链接的目标文件，获得各个段的长度和位置，将每个目标文件中的符号表收集起来，组成统一的全局符号表。
第二部，使用第一步收集的数据进行符号解析和重定位。


通常情况下在编写程序时会引用其他源文件或者动态库中定义的函数或者类方法以及全局变量，因此在编译阶段所有的外部引用符号的地址是无法被确定的，
此时生成的目标文件中的段(Segment)中的节(Section)中的外部函数调用指令的操作数部分以及外部全局变量符号的地址的值都将是0。在后续的链接过程中需要调整这些指令的操作数的值来进行重定位(Relocation)，为此系统在编译的目标文件中的对那些有外部符号引用的节(Section)中都会建立一个重定位表(Relocation table)。这个重定位表中的每个条目会将所有需要进行重定位的指令或者数据访问的位置信息以及引用的外部符号的信息记录起来，以便在链接时进行更新处理。下面的图表展示了这个结构：

```c
struct relocation_info {
   int32_t	r_address;	/* offset in the section to what is being relocated */
   uint32_t r_symbolnum:24,	/* symbol index if r_extern == 1 or section ordinal if r_extern == 0 */
            r_pcrel:1, 	/* was relocated pc relative already */
		    r_length:2,	/* 0=byte, 1=word, 2=long, 3=quad */
		    r_extern:1,	/* does not include value of sym referenced */
		    r_type:4;	/* if not 0, machine specific relocation type */
};
```


## 空间与地址分配
##### 目标文件的合并
因为每个段都有地址和空间对齐的要求，为了提高空间的利用率，所以采用相似段合并的策略。（这里需要提到目标文件的段的定义）
在这只关注text段和data段。




#####

### 重定位表


1.重定位的需求:
在生成程序的时候,很多涉及到地址的代码,都使用一个绝对的虚拟内存地址(这个虚拟内存地址是假设程序加载到0x400000的地方时才能够使用的),但是当程序的加载基址产生变化的时候,新的加载基址和默认的加载基址就不一样了,那些涉及到地址的代码就不能运行了,此时就需要将那些涉及到地址的代码,把他们的操作数修改(去掉默认加载基址,再加上新的加载基址)才能够使程序运行起来.
2.产生重定位需求的代码

当代码段使用了其他区段的数据,所生成的代码就会产生重定位的需求,其他段数据的首地址,就是产生重定位需求的根源
凡是出现全局变量的地方,都会导致重定位的产生
调用外部模块的函数都会产生重定位

3.怎么修复重定位
0x0谁来修复重定位?

加载器会负责修复所有会产生重定位的代码

0x1重定位怎么被修复?
0x1-1如何知道哪些地址上的代码会产生重定位?

利用重定位表去知道产生产生重定位代码的地址
重定位表所记录的信息:在哪个地址上产生了重定位。

0x1-2如何修改?

将指令中的操作数按照指针字节数读取出来,然后将之减去默认加载基址(扩展头.ImageBase),在加上新的加载基址,最后把新地址存入原来的地址中.

0x1-3要修改的是什么?
要修改的内存地址操作数:0x403000
0x401000 A3 00304000 ------>对应汇编指令: mov dword ptr ds:[0x403000] ,eax
被修改的四个字节(0x4010001)
重定位块中的VirtualAddress+offset得到的是0x401001
*(DWORD*)0x401001得到的是----->0x403000

修复重定位(假定默认基址为0x40 0000,新的加载基址0x30 0000):

*(DWORD*)(VirtualAddress+offset+当前加载基址)-=0x400000
*(DWORD*)(VirtualAddress+offset+当前加载基址)+=0x300000




## link 

### lipo 
* lipo -info xxx                                    // 查看支持的cpu 架构列表
* lipo -create xxxx  xxxx  -output xxxx             // 整合成Fat文件
* lipo xxxx -thin cpu(armv7/arm64等)  -output  xxxx  // 提取特定的cpu架构的thin文件
* lipo -remove cpu(armv7/arm64等) xxxx -output  xxxx //移除掉特定的cpu架构的文件

### otool
* otool 
```shell
-d print the data section 
-f print the fat headers 
-l print the load commands
-h print the mach header
-t print the text section (disassemble with -v)
-V print disassembled operands symbolically
```

### ar
可以用来创建、修改和提取库
-x filename

### nm 命令详解
列出目标文件的标识

命令格式
nm [option(s)] [file(s)]

```
有用的options:
-A 在每个符号信息的前面打印所在对象文件名称；
-C 输出demangle过了的符号名称；
-D 打印动态符号；
-l 使用对象文件中的调试信息打印出所在源文件及行号；
-n 按照地址/符号值来排序；
-u 打印出那些未定义的符号；
常见的符号类型:

A 该符号的值在今后的链接中将不再改变；
B 该符号放在BSS段中，通常是那些未初始化的全局变量；
D 该符号放在普通的数据段中，通常是那些已经初始化的全局变量；
T 该符号放在代码段中，通常是那些全局非静态函数；
U 该符号未定义过，需要自其他对象文件中链接进来；
W 未明确指定的弱链接符号；同链接的其他对象文件中有它的定义就用上，否则就用一个系统特别指定的默认值。
```

### 编译
C/C++的编译器是集成的，编译一边分为4个过程：

1、预处理阶段 ： 从hello.c变成hello.i文件，预处理一般就是将include或者define之类的东西，插入到代码中；

2、编译 ： 从hello.i 变成hello.s文件，过程：检查语法、规范，在确定无误之后，将代码翻译成汇编语言。

3、汇编 ： 从hello.s 变成hello.o文件，过程：将汇编代码转换成二进制文件。

4、连接 ： 根据目标文件以及库文件，完成链接之后，生成可执行文件。


