# 性能优化 小记

1. 合理的线程分配
处理同一类的、频繁的事件，可以在固定的线程中处理。
AFNetwork中 urlconnect 就有类似操作，保活一个线程，所有的operater都在这个线程内操作，不会多次开启线程（线程开启也是很耗内存的，主线程1M，子线程512KB）。
所以 一些频繁的固定操作， 可在固定线程内操作， 避免多次启动线程。比如 DB的操作、日志记录、网络 数据请求等。

2. 预处理 和 延迟加载
预处理：对于一些特别耗资源和时间的操作， 可以预先在后台线程中处理，在需要显示时，就不需要另外等待处理。（SDWebImage 的 图片从硬盘加载到内存中就是一个耗时操作，SDWebImage的策略是，将本来默认在主线程中的操作 提交到 子线程中，防止主线程卡顿）

延时加载：将一些当前必须的可视内容，在稍后一段时间内或特定事件时，再触发其他内容的加载。这种方式可以很有效的提升界面绘制速度，使体验更加流畅。

3. 缓存 cache
缓存能 有效 提高性能， 对于一些 已经处理过的数据， 一个良好的缓存能减少 不必要的IO操作，iOS的SDWebImage 有缓存机制， 对于一些已经 解码过的 或 已经下载的image， 会缓存起来， 能 有效避免重复下载， 减少不必要的操作。
但是 缓存 也存在一些问题
并发访问 cache 时，数据一致性问题。
cache 线程安全问题，防止一边修改一边遍历的 crash。
cache 查找时性能问题。
cache 的释放与重建，避免占用空间无限扩大，同时释放的粒度也要依实际需求而定。

# CPU 资源消耗原因和解决方案

1. 对象创建
* 不需要响应触摸事件的控件：CALayer显示
* 对象不涉及UI操作，则尽量放到后台线程创建
* 包含有CALayer的控件只能在主线程创建和操作
* 通过Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，storyboard不是一个好的技术选择
* 尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。
* 对象的复用代价比释放，创建新对象要小，这类对象应当尽量放到一个缓存池里复用

2. 对象调整
* CALayer:CALayer内部并没有属性，当调用属性方法时，它内部是通过运行时resolveInstanceMethod为对象临时添加一个方法，并把对应属性值保存到内部的一个Dictionary里，同时还会通知delegate，创建动画等等，非常消耗资源。
tips : + (id)defaultValueForKey:(NSString *)key; 会调用这个方法
* UIView的关于显示相关的属性（frame/bound/transform）等实际上都是CALayer属性映射来的，所以对UIView的这些属性进行调整时，消耗的资源要远大于一般的属性，所以，尽量减少不必要的属性修改
* 当视图层次调整时，UIView，CALayer之间会出现很多方法调用与通知，所以，应尽量避免调整视图层次，添加和移除视图。

3. 对象销毁

* 把对象捕获到block中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。

```objc
NSArray *tmp = self.array;
self.array = nil;
dispatch_async(queue,^{
    [tmp class];
});
```

4. 布局计算

* 视图布局的计算是App中最为常见的消耗CPU资源的地方
* 在后台线程提前计算好视图布局，并且对视图布局进行缓存
* 用任何技术对视图进行布局，最终都会落到对UIView.frame/bounds/center等属性的调整上 对象调整：非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次，频繁的计算和调整这些属性。

5. 文本渲染

* 所有的文本内容控件，在底层都是通过CoreText排版，绘制为Bitmap显示的。
* 常见的文本控件(UILabel,UITextView)，其排版和绘制都是在主线程进行的，当显示大量文本时，CPU的压力会非常大。
* 解决方案：自定义文本控件，用TextKit或底层的CoreText对文本异步绘制
* CoreText对象创建好后，能直接获取文本的宽高信息，避免了多次计算（调整UILabel大小时算一遍，UILabel绘制时内部再算一遍），CoreText对象占用内存较少，可以缓存下来供稍后多次渲染。

6. 图片解码

* 当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。

* 图像绘制：以CG开头的方法把图像绘制到画布中，然后从画布创建图片并显示 如：[UIView drawRect:]
* CoreGraphic 方法通常是线程安全的，图像的绘制可以放到后台线程进行
```objc
- (void)display{
    dispatch_async(backgroundQueue,^{
        CGContextRef ctx = CGBitmapContextCreate(...);
        // draw in context...
        CGImageRef img = CGBitmapContextCreateImage(ctx);
        CFRelease(ctx);
        dispatch_async(mainQueue,^{
            layer.contents = img;
        });
});
}
```

# GPU 资源消耗原因和解决方案

1. 纹理的渲染
* 所有的Bitmap ，包括图片，文本，栅格化的内容，最终都要由内存提交到显存，绑定为GPU Texture.
* 提交到显存的过程，GPU调整和渲染Texture的过程，都要消耗不少GPU资源
* 当在较短时间显示大量图片（TableView存在非常多的图片并且快速滑动时），CPU占有率很低，GPU占有非常高，界面仍然会掉帧。
* 尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。
* 图片过大，超过GPU的最大纹理尺寸时，图片需要先由CPU进行预处理，这对CPU和GPU都会带来额外的资源消耗。iPhone4S以上机型，纹理尺寸上限4096*4096

2. 视图的混合

* 当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。

3. 图的生成

* CALayer的border,圆角，阴影，遮罩(mask),CASharpLayer的矢量图形显示，通常会触发离屏渲染(offscreen rendering)，而离屏渲染通畅发生在GPU中。
* 当一个列表视图中出现大量圆角的CALayer，并且快速滑动时，可以观察到GPU资源已经占满，而CPU资源消耗很少。界面仍然能正常滑动，但平均帧数会降到很低
* 避免这种情况，可以尝试开启CALayer.shouldRasterize（栅格化）属性，但这会把原本离屏渲染的操作转嫁到CPU上去。
* 圆角图片遮挡
* 把需要显示的图形在后台线程绘制为图片，避免使用圆角，阴影，遮罩等属性。