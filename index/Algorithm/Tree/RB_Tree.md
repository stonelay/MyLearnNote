# rb_tree

从根到叶子的最长路径不多于最短路径的两倍长。所以红黑树是大致上是平衡的（不像AVL-tree，要求绝对平衡）。树的插入、删除和查找效率与树的高度成比例，红黑树的高度上限允许在最坏情况下都是高效的，这是红黑树相对于其他二叉搜索树最大的优势。

算法导论对R-B Tree的介绍：
红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。
通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。

红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。

它的统计性能要好于平衡二叉树（AVL树）。

# rb_tree 性质

1. 每个结点要么是红的要么是黑的。  
2. 根结点是黑的。  
3. 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。  
4. 如果一个结点是红的，那么它的两个儿子都是黑的。  
5. 对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。 

红黑树是牺牲了严格的高度平衡的优越条件为代价红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高.

# rb_tree 插入修复

* 不需要修复。如果插入的是根结点:
由于原树是空树，此情况只会违反性质2，因此直接把此结点涂为黑色。

* 不需要修复。如果插入的结点的父结点是黑色:
由于此不会违反性质2和性质4，红黑树没有被破坏，所以此时什么也不做。

* 需要修复情况1，如果当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色
此时父结点的父结点一定存在，否则插入前就已不是红黑树。与此同时，又分为父结点是祖父结点的左孩子还是右孩子，根据对称性，我们只要解开一个方向就可以了。对此，我们的解决策略是:将当前节点的父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点，从新的当前节点重新开始算法。插入修复情况1转换成了插入修复情况2。

* 需要修复情况2，当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的右子
解决方案:当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。从而插入修复情况2转换成了插入修复情况3。

* 需要修复情况3，当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的左子
解决对策是:父节点变为黑色，祖父节点变为红色，在祖父节点为支点右旋,最后，把根结点涂为黑色，整棵红黑树便重新恢复了平衡。